<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Benchmark on gywn&#39;s tech</title>
    <link>//localhost:1313/tags/benchmark/</link>
    <description>Recent content in Benchmark on gywn&#39;s tech</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>gywndi@gmail.com (gywndi)</managingEditor>
    <webMaster>gywndi@gmail.com (gywndi)</webMaster>
    <lastBuildDate>Fri, 15 Jun 2012 06:15:02 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/tags/benchmark/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL에서 Temporary Table을 활용한 데이터 질의..그 효과는?</title>
      <link>//localhost:1313/2012/06/mysql-temporary-table-effect/</link>
      <pubDate>Fri, 15 Jun 2012 06:15:02 +0000</pubDate><author>gywndi@gmail.com (gywndi)</author>
      <guid>//localhost:1313/2012/06/mysql-temporary-table-effect/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;오늘은 Temporary Table에 관해 포스팅을 하겠습니다. Select및 Update 등을 이따금씩 Temporary Table을 활용하여 수행하는 경우가 있습니다. 동시에 많은 데이터를 일괄 변경하는 것에서는 분명 강점이 있을 것이라 판단되는데, 어떤 상황에서 적절하게 사용하는 것이 좋을까요? 관련 성능 벤치마크 결과를 공개하겠습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;environment&#34;&gt;&lt;strong&gt;Environment&lt;/strong&gt;&lt;/h1&gt;&#xA;&lt;p&gt;테이블에는 약 1000만 건 데이터가 존재하며, Primary Key외에는 추가 인덱스는 생성하지 않았습니다. 서로 동등하게 빠른 데이터 접근이 가능하다는 가정 하에 PK외 인덱스에서 발생할 수 있는 성능 저하 요소를 배제하기 위해서 입니다.^^&lt;/p&gt;</description>
    </item>
    <item>
      <title>디스크 병목 현상에 따른 DB 성능 리포트</title>
      <link>//localhost:1313/2012/03/database-performance-report-on-disk-bottleneck/</link>
      <pubDate>Sun, 18 Mar 2012 10:05:35 +0000</pubDate><author>gywndi@gmail.com (gywndi)</author>
      <guid>//localhost:1313/2012/03/database-performance-report-on-disk-bottleneck/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;어느 시스템에서도 병목 현상은 어딘가에 있습니다. DBMS 또한 CPU, Memory, Disk로 구성된 하나의 시스템이기 때문에 당연히 특정 구역에서 병목현상이 발생할 수 있죠. 오늘은 Disk에서 발생하는 병목에 관해서 말씀드리겠습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;memory-processing&#34;&gt;Memory Processing&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;//localhost:1313/2012/03/db-performance-disk-raid-configuration/&#34;&gt;Permanent Link: 디스크 배열(RAID)에 따른 DB 성능 비교&lt;/a&gt; 에서, 메모리가 충분하면 아래와 같다는 그래프를 보여드렸습니다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;//localhost:1313/img/2012/03/buffer_pool_12G_disk1.png&#34; alt=&#34;InnoDB Buffer Pool : 12G&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;어떤 경우든 메모리에만 연산이 가능하다면, CPU자원을 거의 활용 가능하다고 할 수 있죠. 그러나 만약 디스크 I/O가 발생하는 순간부터 CPU는 전혀 연산하지 않는 현상이 발생합니다. 바로 디스크 I/O Wait 으로 인한 시스템 병목 현상 발생입니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>디스크 배열(RAID)에 따른 DB 성능 비교</title>
      <link>//localhost:1313/2012/03/db-performance-disk-raid-configuration/</link>
      <pubDate>Sun, 18 Mar 2012 09:43:46 +0000</pubDate><author>gywndi@gmail.com (gywndi)</author>
      <guid>//localhost:1313/2012/03/db-performance-disk-raid-configuration/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;MySQL DBMS 하드웨어 구성 시 어떠한 정책으로 움직이는 것이 가장 효율적일지, 메모리/디스크 설정을 변경하여 테스트를 진행하였습니다. 디스크는 RAID 레벨을 변경하였고, innodb_buffer_pool을 조정함으로써 메모리 환경을 구성하였습니다. 서비스 특성에 따라 하드웨어 구성을 달리함으로써, 장비를 더욱더 효율적으로 사용할 수 있을 것으로 기대됩니다.^^&lt;/p&gt;&#xA;&lt;h1 id=&#34;디스크배열raid란&#34;&gt;디스크배열(RAID)란?&lt;/h1&gt;&#xA;&lt;p&gt;RAID란 Redundant Array of Inexpensive Disks의 약자로 디스크를 여러장 묶어서, 데이터 중복성 및 성능 향상을 유도할 수 있는 기법입니다. RAID 기법은 참으로 많이 있으나, 일반적으로 실무에서는 RAID0, RAID1, RAID5, RAID10또는 RAID01을 많이 사용합니다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
